datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            String          @id @default(cuid())
  name          String?
  email         String          @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  username      String?         @unique
  // Optional for WebAuthn support
  Authenticator Authenticator[]

  quizes     Quiz[]
  likes      Like[]
  bookmarked Bookmarked[]
  Progress   Progress[]
  scores     Score[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Quiz {
  id         String       @id @default(cuid())
  title      String
  description String?
  questions  Question[]
  progress   Progress[]
  likes      Like[]
  score      Score[]
  bookmarked Bookmarked[]

  stickers String[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  category   Category
  difficulty Difficulty

  author   User   @relation(fields: [authorId], references: [id])
  authorId String
}

model Question {
  id       String     @id @default(cuid())
  text     String
  image    String?
  options  Answer[]
  progress Progress[]

  questionType QuestionType

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  quiz   Quiz   @relation(fields: [quizId], references: [id])
  quizId String
}

model Answer {
  id        String  @id @default(cuid())
  text      String
  isCorrect Boolean
  order     Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  question   Question @relation(fields: [questionId], references: [id])
  questionId String
}

model Progress {
  id    String   @id @default(cuid())
  score Score[]
  timer DateTime @default(now())
  tries Int @default(5)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user              User      @relation(fields: [userId], references: [id])
  userId            String
  quiz              Quiz      @relation(fields: [quizId], references: [id])
  quizId            String
  question          Question? @relation(fields: [currentQuestionId], references: [id])
  currentQuestionId String
}

model Score {
  user       User     @relation(fields: [userId], references: [id])
  userId     String
  quiz       Quiz     @relation(fields: [quizId], references: [id], onDelete: Cascade)
  quizId     String
  progress   Progress @relation(fields: [progressId], references: [id])
  progressId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([userId, quizId, progressId])
}

enum QuestionType {
  FILL_BLANKS
  PICK_ANSWER
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
}

model Like {
  user   User   @relation(fields: [userId], references: [id])
  userId String
  quiz   Quiz   @relation(fields: [quizId], references: [id], onDelete: Cascade)
  quizId String

  @@id([userId, quizId])
}

model Bookmarked {
  user   User   @relation(fields: [userId], references: [id])
  userId String
  quiz   Quiz   @relation(fields: [quizId], references: [id], onDelete: Cascade)
  quizId String

  @@id([userId, quizId])
}

enum Category {
  MATH
  SPORT
  ART
  GEOGRAPHY
  PROGRAMMING
  SCIENCE
  CARS
  FOOD
  ANIMALS
  NATURE
  TECHNOLOGY
  HISTORY
  LITERATURE
  POLITICS
  SPACE
  HEALTH
  FASHION
  LANGUAGES
  TRAVEL
  CULTURE
  ECONOMICS
  BUSINESS
  MYTHOLOGY
  ARCHITECTURE
  PSYCHOLOGY
  EDUCATION
  PHILOSOPHY
  ENVIRONMENT
  SOCIOLOGY
  RELIGION
  ENGINEERING
  MEDIA
  GAMES
  LAW
  MATHEMATICS
  DESIGN
  ANTHROPOLOGY
  ASTRONOMY
  CHEMISTRY
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}

// Optional for WebAuthn support
model Authenticator {
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, credentialID])
}
